<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Santa Stacker - World Tour</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center bottom, #1e293b 0%, #0f172a 40%, #020617 100%);
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .hud-score {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 4rem;
            font-weight: 900;
            opacity: 0.3;
            pointer-events: auto; /* Changed to auto to allow gesture taps */
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            z-index: 20; /* Brought forward for clicking */
            transition: transform 0.1s;
            cursor: pointer; /* Hint that it's interactive */
        }
        
        /* Gift Ticker Styles */
        .gift-ticker {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            color: #0f172a;
            padding: 0.75rem 1.5rem;
            border-radius: 999px;
            font-weight: 700;
            font-size: 1.1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 20;
            border: 2px solid #ef4444;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            white-space: nowrap;
        }
        .gift-ticker.active {
            opacity: 1;
        }
        .gift-price {
            color: #16a34a;
            font-weight: 800;
        }

        .start-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 2.5rem;
            border-radius: 2rem;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transition: transform 0.2s;
            max-width: 90%;
            width: 400px;
        }
        .game-over-modal {
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 1.5rem;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(220, 38, 38, 0.4);
            display: none;
            transform: scale(0.9) translateY(20px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 4px solid #ef4444;
            max-width: 90%;
            width: 380px;
        }
        .game-over-modal.active {
            display: block;
            transform: scale(1) translateY(0);
            opacity: 1;
        }
        .title-gradient {
            background: linear-gradient(to right, #ef4444, #22c55e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        
        .city-select-wrapper {
            position: relative;
            margin-bottom: 1.5rem;
        }
        .city-select {
            appearance: none;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            width: 100%;
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-weight: 600;
        }
        .select-arrow {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: rgba(255,255,255,0.7);
        }

        /* Value Summary Styling */
        .value-summary {
            background: #f1f5f9;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            text-align: left;
        }
        .fail-msg {
            color: #dc2626;
            font-style: italic;
            font-weight: 600;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            border-top: 1px solid #cbd5e1;
            padding-top: 0.5rem;
        }
    </style>
</head>
<body>

    <!-- Gift Ticker -->
    <div id="giftTicker" class="gift-ticker">
        <span>üì¶ Delivering:</span>
        <span id="giftName">...</span>
        <span id="giftPrice" class="gift-price">$0</span>
    </div>

    <div class="hud-score" id="scoreVal">0</div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <!-- New Hint Element -->
        <div id="gameHint" class="absolute top-[30%] left-0 w-full text-center pointer-events-none transition-opacity duration-500 opacity-0 z-30">
            <div class="inline-block bg-slate-900/60 backdrop-blur-md px-8 py-4 rounded-2xl border border-white/20 shadow-2xl animate-bounce">
                <p class="text-white text-2xl font-bold tracking-wider drop-shadow-md">
                    üëá TAP or SPACE
                </p>
                <p class="text-yellow-400 text-sm font-bold mt-1 uppercase tracking-widest">
                    to drop perfectly
                </p>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen" class="start-card">
            <!-- Greeting Message (Hidden by default) -->
            <div id="greetingDisplay" class="hidden mb-6">
                <p class="text-yellow-400 font-bold text-lg md:text-xl drop-shadow-md leading-snug" style="text-wrap: balance;">
                    ‚ú® Seasons Greetings from <span id="senderName" class="text-white"></span>! ‚ú®
                </p>
            </div>

            <div class="text-6xl mb-2">üéÖ</div>
            <h1 class="text-4xl md:text-5xl font-black title-gradient mb-2 tracking-tight">
                SANTA STACKER
            </h1>
            <p class="text-blue-100 text-lg font-medium mb-6 opacity-90">
                Select your delivery zone:
            </p>
            
            <div class="city-select-wrapper">
                <select id="citySelect" class="city-select">
                    <option value="New York">New York</option>
                    <option value="Hong Kong">Hong Kong</option>
                    <option value="London">London</option>
                </select>
                <div class="select-arrow">‚ñº</div>
            </div>

            <button id="startBtn" class="inline-block w-full px-8 py-4 bg-red-600 hover:bg-red-500 text-white font-bold rounded-xl shadow-lg transition-all transform hover:-translate-y-1 active:translate-y-0 text-xl mb-4">
                START DELIVERY
            </button>

            <!-- Share Button -->
            <button id="openShareBtn" class="text-blue-200 text-sm hover:text-white hover:underline transition-colors flex items-center justify-center w-full gap-2">
                <span>üéÅ</span> Share this Greeting to a Friend
            </button>
        </div>

        <!-- Share Modal -->
        <div id="shareModal" class="game-over-modal z-50">
            <h2 class="text-2xl font-bold text-slate-800 mb-2">Send a Holiday Greeting</h2>
            <p class="text-slate-500 text-sm mb-4">Enter your name to create a personalized game link for your friends!</p>
            
            <input type="text" id="shareNameInput" placeholder="Your Name (e.g. Santa)" class="w-full p-3 rounded-lg border-2 border-slate-200 mb-4 text-slate-800 text-center font-bold focus:outline-none focus:border-red-500 transition-colors" maxlength="25">
            
            <button id="generateLinkBtn" class="w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-md transition-all mb-2">
                Copy Link üìã
            </button>
            
            <p id="shareFeedback" class="text-green-600 font-bold text-sm h-6 transition-opacity opacity-0">Link Copied! Send it to anyone.</p>
            
            <button id="closeShareBtn" class="text-slate-400 text-sm hover:text-slate-600 mt-2">Close</button>
        </div>

        <div id="gameOverScreen" class="game-over-modal">
            <div class="text-5xl mb-2">üéÅ</div>
            <h2 class="text-3xl font-black text-slate-800 mb-4">DELIVERY DONE</h2>
            
            <div class="value-summary">
                <div class="flex justify-between mb-1">
                    <span class="text-slate-600">Height:</span>
                    <span class="font-bold text-slate-800" id="finalScore">0</span>
                </div>
                <div class="flex justify-between mb-2">
                    <span class="text-slate-600">Total Value:</span>
                    <span class="font-bold text-green-600" id="finalValue">$0</span>
                </div>
                <div id="failMessage" class="fail-msg">
                    <!-- Dynamic Fail Message -->
                </div>
            </div>
            
            <div id="nextUnlock" class="text-sm text-purple-600 font-bold mb-4 bg-purple-50 p-2 rounded-lg border border-purple-100">
                <!-- Javascript will fill this -->
            </div>

            <button id="restartBtn" class="w-full py-4 bg-green-600 hover:bg-green-500 text-white font-bold rounded-xl shadow-lg transition-all transform hover:-translate-y-1 active:translate-y-0">
                STACK AGAIN
            </button>
        </div>
    </div>

    <script>
        // --- Gift Data ---
        const GIFTS = [
            { name: "Lump of Coal", price: 0, fail: "You definitely belong on the naughty list." },
            { name: "Wool Socks", price: 5, fail: "Grandma is going to be so disappointed." },
            { name: "Fruitcake", price: 15, fail: "It's practically a brick anyway." },
            { name: "Gift Card", price: 25, fail: "It was probably expired." },
            { name: "Ugly Sweater", price: 45, fail: "Fashion disaster averted." },
            { name: "Video Game", price: 60, fail: "Game Over literally." },
            { name: "Fancy Headphones", price: 150, fail: "Can't hear the haters now." },
            { name: "Smart Watch", price: 250, fail: "Time ran out on that one." },
            { name: "Espresso Machine", price: 400, fail: "A bitter shot to take." },
            { name: "PS5 Pro", price: 700, fail: "Scalpers are crying right now." },
            { name: "iPhone 17", price: 1200, fail: "Siri says: 'That hurt'." },
            { name: "Gaming PC", price: 2500, fail: "Blue screen of death." },
            { name: "85\" TV", price: 3500, fail: "That smashed screen isn't covered." },
            { name: "Used Honda Civic", price: 5000, fail: "VTEC failed to kick in." },
            { name: "Diamond Ring", price: 10000, fail: "That relationship is over." },
            { name: "Rolex", price: 15000, fail: "Expensive mistake." },
            { name: "Cybertruck", price: 80000, fail: "Not as durable as claimed." },
            { name: "Space Ticket", price: 250000, fail: "Houston, we have a problem." }
        ];

        // --- Game Constants & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const scoreEl = document.getElementById('scoreVal');
        const finalScoreEl = document.getElementById('finalScore');
        const finalValueEl = document.getElementById('finalValue');
        const failMessageEl = document.getElementById('failMessage');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartBtn = document.getElementById('restartBtn');
        const startBtn = document.getElementById('startBtn');
        const citySelect = document.getElementById('citySelect');
        const nextUnlockEl = document.getElementById('nextUnlock');
        
        // Share Elements
        const openShareBtn = document.getElementById('openShareBtn');
        const shareModal = document.getElementById('shareModal');
        const closeShareBtn = document.getElementById('closeShareBtn');
        const generateLinkBtn = document.getElementById('generateLinkBtn');
        const shareNameInput = document.getElementById('shareNameInput');
        const shareFeedback = document.getElementById('shareFeedback');
        const greetingDisplay = document.getElementById('greetingDisplay');
        const senderNameEl = document.getElementById('senderName');

        const giftTicker = document.getElementById('giftTicker');
        const giftNameEl = document.getElementById('giftName');
        const giftPriceEl = document.getElementById('giftPrice');

        // Game Configuration
        const BASE_HEIGHT = 45; 
        const INITIAL_WIDTH = 280; 
        const INITIAL_SPEED = 2; 
        const SPEED_INCREMENT = 0.2; 
        
        // Palette
        const PALETTE = [
            { main: '#dc2626', ribbon: '#fbbf24' }, // Red & Gold
            { main: '#16a34a', ribbon: '#ffffff' }, // Green & White
            { main: '#2563eb', ribbon: '#cbd5e1' }, // Blue & Silver
            { main: '#ffffff', ribbon: '#dc2626' }, // White & Red
            { main: '#7c3aed', ribbon: '#fbbf24' }, // Purple & Gold
            { main: '#db2777', ribbon: '#fce7f3' }, // Pink & Light
        ];

        // State
        let state = 'start';
        let score = 0;
        let totalValue = 0;
        let blocks = [];
        let activeBlock = null;
        let activeGift = null; // The gift currently moving
        let debris = [];
        let easterEggs = []; // New Array for Easter Eggs
        let cameraY = 0;
        let targetCameraY = 0;
        let snowflakes = [];
        let stars = [];
        let animationFrameId;
        let currentCity = 'New York';
        let citySkyline = [];
        
        // Easter Egg State
        let auroraActive = false;
        let auroraAlpha = 0;

        // --- Classes ---

        class EasterEgg {
            constructor(type, startY) {
                this.type = type;
                this.active = true;
                
                // Position relative to the game world (using startY which is -cameraY)
                if (type === 'shooting_star') {
                    this.x = -100;
                    this.y = startY + Math.random() * (canvas.height/2);
                    this.vx = 15;
                    this.vy = 5;
                    this.size = 2;
                } else if (type === 'plane') {
                    this.x = canvas.width + 300; // Start far right
                    this.y = startY + 150;
                    this.vx = -3;
                    this.vy = 0;
                } else if (type === 'rocket') {
                    this.x = Math.random() * (canvas.width - 100) + 50;
                    this.y = startY + canvas.height + 200; // Start below screen
                    this.vx = 0;
                    this.vy = -12; // Fast up
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Deactivation logic
                if (this.type === 'shooting_star' && this.x > canvas.width + 200) this.active = false;
                if (this.type === 'plane' && this.x < -600) this.active = false;
                if (this.type === 'rocket' && this.y < this.y - canvas.height - 1000) this.active = false; // Just let it fly up forever basically
            }

            draw(ctx) {
                if (!this.active) return;
                
                if (this.type === 'shooting_star') {
                    ctx.save();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - 50, this.y - 15); // Trail
                    ctx.stroke();
                    
                    // Star head
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glow
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#fff';
                    ctx.fill();
                    ctx.restore();
                } 
                else if (this.type === 'plane') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Plane body (Simple Silhouette)
                    ctx.fillStyle = '#0f172a';
                    ctx.fillRect(0, 0, 40, 10);
                    ctx.beginPath(); 
                    ctx.moveTo(10, 0); ctx.lineTo(15, -10); ctx.lineTo(25, 0); ctx.fill(); // Top wing
                    ctx.beginPath();
                    ctx.moveTo(5, 5); ctx.lineTo(0, 15); ctx.lineTo(10, 5); ctx.fill(); // Tail
                    
                    // Propeller
                    if (Date.now() % 100 > 50) {
                        ctx.fillStyle = 'rgba(255,255,255,0.5)';
                        ctx.fillRect(-5, -5, 5, 20);
                    }

                    // Banner
                    const text = "DON'T LOOK DOWN!";
                    ctx.font = "bold 16px sans-serif";
                    const textWidth = ctx.measureText(text).width + 20;
                    
                    // String
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(40, 5);
                    ctx.lineTo(60, 5);
                    ctx.stroke();

                    // Banner Rect
                    ctx.fillStyle = '#f1f5f9';
                    ctx.fillRect(60, -10, textWidth, 30);
                    ctx.fillStyle = '#dc2626';
                    ctx.fillText(text, 70, 10);

                    ctx.restore();
                }
                else if (this.type === 'rocket') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Flame
                    ctx.fillStyle = `rgba(255, ${Math.random()*100 + 100}, 0, 0.8)`;
                    ctx.beginPath();
                    ctx.moveTo(-10, 40);
                    ctx.lineTo(0, 40 + Math.random() * 40);
                    ctx.lineTo(10, 40);
                    ctx.fill();

                    // Body
                    ctx.fillStyle = '#e2e8f0';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 15, 40, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fins
                    ctx.fillStyle = '#475569';
                    ctx.beginPath();
                    ctx.moveTo(-10, 20); ctx.lineTo(-25, 40); ctx.lineTo(-10, 35); ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(10, 20); ctx.lineTo(25, 40); ctx.lineTo(10, 35); ctx.fill();

                    // Window
                    ctx.fillStyle = '#0ea5e9';
                    ctx.beginPath();
                    ctx.arc(0, -10, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            }
        }

        class Block {
            constructor(x, y, width, colorIndex, speed = 0, isDebris = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                if (!isDebris) {
                    const widthBonus = Math.min(15, (width - 50) * 0.05);
                    this.height = Math.floor(BASE_HEIGHT + Math.max(0, widthBonus));
                } else {
                    this.height = BASE_HEIGHT;
                }
                this.colorIndex = colorIndex;
                this.colors = PALETTE[colorIndex % PALETTE.length];
                this.vx = speed;
            }

            update() {
                this.x += this.vx;
                if (this.x + this.width > canvas.width) {
                    this.x = canvas.width - this.width;
                    this.vx *= -1;
                } else if (this.x < 0) {
                    this.x = 0;
                    this.vx *= -1;
                }
            }

            draw(ctx, isTop = false) {
                const { main, ribbon } = this.colors;
                const h = this.height;
                const w = this.width;
                const x = this.x;
                const y = this.y;

                const grad = ctx.createLinearGradient(x, y, x + w, y);
                grad.addColorStop(0, adjustColor(main, -20));
                grad.addColorStop(0.5, main);
                grad.addColorStop(1, adjustColor(main, -20));
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, 4);
                ctx.fill();

                const rW = Math.max(6, w * 0.15);
                const rX = x + (w - rW) / 2;
                ctx.fillStyle = ribbon;
                ctx.fillRect(rX, y, rW, h);

                const rH = 6;
                const rY = y + (h - rH) / 2;
                ctx.fillRect(x, rY, w, rH);
                
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(x, y, w, h * 0.1); 

                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(x, y + h - 5, w, 5); 

                drawBow(ctx, x + w/2, y, ribbon);
            }
        }

        class Debris extends Block {
            constructor(x, y, width, height, colorIndex, vx) {
                super(x, y, width, colorIndex, vx, true);
                this.height = height; 
                this.vy = 2;
                this.alpha = 1;
                this.rot = 0;
                this.rotSpeed = (Math.random() - 0.5) * 0.1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.8; 
                this.alpha -= 0.02;
                this.rot += this.rotSpeed;
            }

            draw(ctx) {
                if (this.alpha <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rot);
                ctx.translate(-(this.x + this.width/2), -(this.y + this.height/2));
                super.draw(ctx);
                ctx.restore();
            }
        }

        class Sleigh {
            draw(ctx, block) {
                const x = block.x + block.width / 2;
                const y = block.y; 

                ctx.save();
                ctx.translate(x, y);

                // Flip if moving left
                if (block.vx < 0) ctx.scale(-1, 1);

                // --- Reindeer ---
                ctx.fillStyle = '#854d0e'; // Brown
                
                // Body
                ctx.beginPath();
                ctx.ellipse(20, -12, 12, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Legs
                ctx.fillRect(14, -6, 3, 6);
                ctx.fillRect(26, -6, 3, 6);

                // Head
                ctx.beginPath();
                ctx.ellipse(32, -16, 5, 3, -0.3, 0, Math.PI * 2);
                ctx.fill();

                // Antlers (simple lines)
                ctx.strokeStyle = '#fce7f3'; // Light color
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(34, -18); ctx.lineTo(38, -24);
                ctx.moveTo(34, -18); ctx.lineTo(30, -24);
                ctx.stroke();
                
                // Red Nose
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.arc(36, -15, 1.5, 0, Math.PI*2);
                ctx.fill();


                // --- Sleigh ---
                ctx.fillStyle = '#dc2626'; // Red Sleigh body
                ctx.beginPath();
                ctx.moveTo(-5, -2);
                ctx.lineTo(-25, -2); // Back
                ctx.quadraticCurveTo(-30, -2, -32, -8); // Back curve up
                ctx.lineTo(-32, -15); // Back top
                ctx.lineTo(-5, -15); // Front top
                ctx.quadraticCurveTo(0, -15, 2, -10); // Front curve
                ctx.lineTo(2, -2);
                ctx.fill();

                // Sleigh Trim/Runners
                ctx.strokeStyle = '#f59e0b'; // Gold
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Top trim
                ctx.moveTo(-32, -15); ctx.lineTo(2, -15);
                // Runner
                ctx.moveTo(-30, -1);
                ctx.lineTo(5, -1);
                ctx.quadraticCurveTo(10, -1, 12, -6);
                ctx.stroke();

                // Reins connecting to reindeer
                ctx.strokeStyle = '#92400e';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(2, -12);
                ctx.lineTo(20, -12);
                ctx.stroke();


                // --- Mini Santa in Sleigh ---
                
                // Body
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.arc(-15, -15, 8, Math.PI, 0);
                ctx.fill();

                // Head
                ctx.fillStyle = '#fca5a5';
                ctx.beginPath();
                ctx.arc(-15, -19, 5, 0, Math.PI*2);
                ctx.fill();
                
                // Beard
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-15, -17, 5, 0, Math.PI);
                ctx.fill();

                // Hat
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.moveTo(-20, -21);
                ctx.lineTo(-10, -21);
                ctx.lineTo(-15, -28);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.fillRect(-20, -21, 10, 3);

                ctx.restore();
            }
        }

        const sleigh = new Sleigh();

        // --- City Generation ---

        function generateSkyline(cityType) {
            let typeCode = 'ny';
            if(cityType === 'Hong Kong') typeCode = 'hk';
            if(cityType === 'London') typeCode = 'london';

            const buildings = [];
            const width = canvas.width;
            let currentX = 0;
            
            while(currentX < width + 100) {
                let bWidth = 40 + Math.random() * 60;
                let bHeight = 100 + Math.random() * 150;
                let type = 'generic'; 
                
                if (typeCode === 'hk') {
                    // HK: Dense, tall, neon, lasers
                    bWidth = 30 + Math.random() * 40;
                    bHeight = 200 + Math.random() * 250;
                    if (Math.random() > 0.8) type = 'hk_bank'; // BoC
                    else if (Math.random() > 0.85) type = 'hk_ifc'; // IFC style
                } else if (typeCode === 'ny') {
                    bWidth = 50 + Math.random() * 50;
                    bHeight = 150 + Math.random() * 200;
                    if (Math.random() > 0.9) type = 'ny_spire';
                } else if (typeCode === 'london') {
                    if (Math.random() > 0.9 && !buildings.some(b => b.type === 'london_eye')) type = 'london_eye';
                    else if (Math.random() > 0.9 && !buildings.some(b => b.type === 'london_ben')) type = 'london_ben';
                    else bHeight = 80 + Math.random() * 100;
                }

                if (type === 'london_eye') { bWidth = 120; bHeight = 140; }
                if (type === 'hk_ifc') { bWidth = 50; bHeight = 350; }

                buildings.push({
                    x: currentX,
                    w: bWidth,
                    h: bHeight,
                    type: type,
                    color: `rgba(15, 23, 42, ${0.8 + Math.random() * 0.2})`, 
                    windowColor: Math.random() > 0.5 ? '#fef08a' : '#e2e8f0',
                    laserColor: Math.random() > 0.5 ? '#22d3ee' : '#a855f7' // Cyan or Purple lasers
                });
                currentX += bWidth - 5; 
            }
            return buildings;
        }

        function drawSkyline(ctx, scrollY) {
            ctx.save();
            const parallaxY = scrollY * 0.3;
            const opacity = Math.max(0, 1 - (scrollY / 2000));
            if (opacity <= 0) {
                ctx.restore();
                return;
            }

            ctx.globalAlpha = opacity;
            ctx.translate(0, parallaxY);

            ctx.fillStyle = '#020617';
            ctx.fillRect(0, canvas.height - 20, canvas.width, canvas.height);

            citySkyline.forEach(b => {
                const yPos = canvas.height - b.h;
                ctx.fillStyle = b.color;
                
                // --- LASERS (HK Feature) ---
                // Adjusted: Only on main landmarks, much fainter opacity, slower movement
                if ((b.type === 'hk_bank' || b.type === 'hk_ifc') && b.h > 200) {
                    ctx.save();
                    ctx.globalAlpha = opacity * 0.08; // Significantly reduced opacity (was 0.3)
                    ctx.strokeStyle = b.laserColor;
                    ctx.lineWidth = 1; // Thinner lines
                    ctx.beginPath();
                    ctx.moveTo(b.x + b.w/2, yPos);
                    // Beam up with reduced sway and slower speed
                    const angle = (Math.sin(Date.now() * 0.0005 + b.x) * 10); 
                    ctx.lineTo(b.x + b.w/2 + angle, yPos - 600);
                    ctx.stroke();
                    ctx.restore();
                }

                if (b.type === 'generic') {
                    ctx.fillRect(b.x, yPos, b.w, b.h);
                    ctx.fillStyle = b.windowColor;
                    ctx.globalAlpha = opacity * 0.5;
                    for(let wy = yPos + 10; wy < canvas.height - 20; wy += 20) {
                        if (Math.random() > 0.3) ctx.fillRect(b.x + 5, wy, 5, 5);
                        if (Math.random() > 0.3) ctx.fillRect(b.x + b.w - 10, wy, 5, 5);
                    }
                    ctx.globalAlpha = opacity;
                } 
                else if (b.type === 'hk_bank') {
                    // Better BoC shape
                    ctx.beginPath();
                    ctx.moveTo(b.x, canvas.height);
                    ctx.lineTo(b.x, yPos + 50); // Base left
                    ctx.lineTo(b.x + b.w/2, yPos); // Tip
                    ctx.lineTo(b.x + b.w, yPos + 50); // Base right
                    ctx.lineTo(b.x + b.w, canvas.height);
                    ctx.fill();
                    
                    // Cross bracing
                    ctx.strokeStyle = '#e2e8f0'; // White bracing
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = opacity * 0.5;
                    ctx.beginPath();
                    // Lower X
                    ctx.moveTo(b.x, canvas.height);
                    ctx.lineTo(b.x + b.w, yPos + 100);
                    ctx.moveTo(b.x + b.w, canvas.height);
                    ctx.lineTo(b.x, yPos + 100);
                    // Upper diamond
                    ctx.moveTo(b.x, yPos + 100);
                    ctx.lineTo(b.x + b.w/2, yPos + 50);
                    ctx.lineTo(b.x + b.w, yPos + 100);
                    ctx.stroke();
                    ctx.globalAlpha = opacity;
                }
                else if (b.type === 'hk_ifc') {
                    // Tall tower with "Crown"
                    ctx.fillRect(b.x, yPos + 20, b.w, b.h - 20); // Body
                    // Tapered Top
                    ctx.beginPath();
                    ctx.moveTo(b.x, yPos + 20);
                    ctx.lineTo(b.x + 5, yPos);
                    ctx.lineTo(b.x + b.w - 5, yPos);
                    ctx.lineTo(b.x + b.w, yPos + 20);
                    ctx.fill();
                    // Vertical light strips
                    ctx.fillStyle = '#fefce8';
                    ctx.globalAlpha = opacity * 0.7;
                    ctx.fillRect(b.x + 10, yPos, 4, b.h);
                    ctx.fillRect(b.x + b.w - 14, yPos, 4, b.h);
                    ctx.globalAlpha = opacity;
                }
                else if (b.type === 'ny_spire') {
                    ctx.fillRect(b.x, yPos + 40, b.w, b.h - 40);
                    ctx.fillRect(b.x + 10, yPos, b.w - 20, 40);
                    ctx.beginPath();
                    ctx.moveTo(b.x + b.w/2, yPos - 20);
                    ctx.lineTo(b.x + 15, yPos);
                    ctx.lineTo(b.x + b.w - 15, yPos);
                    ctx.fill();
                }
                else if (b.type === 'london_ben') {
                    ctx.fillRect(b.x, yPos, b.w, b.h);
                    ctx.beginPath();
                    ctx.moveTo(b.x, yPos);
                    ctx.lineTo(b.x + b.w/2, yPos - 30);
                    ctx.lineTo(b.x + b.w, yPos);
                    ctx.fill();
                    ctx.fillStyle = '#fef08a';
                    ctx.beginPath();
                    ctx.arc(b.x + b.w/2, yPos + 30, 15, 0, Math.PI*2);
                    ctx.fill();
                }
                else if (b.type === 'london_eye') {
                    ctx.strokeStyle = b.color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(b.x + b.w/2, yPos + 50, 50, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(b.x + b.w/2, yPos + 50);
                    ctx.lineTo(b.x, canvas.height);
                    ctx.moveTo(b.x + b.w/2, yPos + 50);
                    ctx.lineTo(b.x + b.w, canvas.height);
                    ctx.stroke();
                }
            });

            ctx.restore();
        }
        
        // --- Draw Aurora ---
        function drawAurora(ctx, scrollY) {
            if (!auroraActive && auroraAlpha <= 0) return;
            
            // Fade in/out
            if (auroraActive && auroraAlpha < 0.6) auroraAlpha += 0.005;
            else if (!auroraActive && auroraAlpha > 0) auroraAlpha -= 0.005;

            ctx.save();
            ctx.globalAlpha = auroraAlpha;
            ctx.translate(0, scrollY * 0.1); // Move slowly

            const time = Date.now() * 0.0005;
            
            // Draw multiple bands
            for(let i=0; i<3; i++) {
                ctx.beginPath();
                ctx.moveTo(0, canvas.height); // Start low
                
                // Bezier curves across screen
                for (let x=0; x <= canvas.width; x+=50) {
                    // Sine wave combination for waviness
                    const y = 200 + (i*50) + Math.sin(x * 0.005 + time + i) * 100 + Math.sin(x * 0.01 - time) * 50;
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(canvas.width, 0);
                ctx.lineTo(0, 0);
                
                const grad = ctx.createLinearGradient(0, 0, 0, canvas.height/2);
                grad.addColorStop(0, `hsla(${120 + i*40}, 80%, 60%, 0.1)`); // Green to purple
                grad.addColorStop(1, `hsla(${160 + i*20}, 80%, 50%, 0)`);
                ctx.fillStyle = grad;
                ctx.fill();
            }

            ctx.restore();
        }

        // --- Helpers ---

        function drawBow(ctx, x, y, color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.translate(x, y);
            ctx.beginPath();
            ctx.ellipse(-6, -4, 6, 3, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(6, -4, 6, 3, 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = adjustColor(color, -30); 
            ctx.beginPath();
            ctx.arc(0, -2, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function adjustColor(color, amount) {
            return '#' + color.replace(/^#/, '').replace(/../g, color => ('0' + Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
        }

        function formatMoney(amount) {
            return '$' + amount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        // --- Setup ---

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Fix: Re-initialize background elements to cover the new screen width
            initBackground();

            if (state === 'start') {
                initGame();
            }
        }
        window.addEventListener('resize', resize);

        function initBackground() {
            snowflakes = Array(100).fill().map(() => ({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 3 + 1,
                speed: Math.random() * 1.5 + 0.5
            }));
            stars = Array(50).fill().map(() => ({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 1.5,
                alpha: Math.random()
            }));
        }

        function initGame() {
            score = 0;
            totalValue = 0;
            scoreEl.textContent = '0';
            blocks = [];
            debris = [];
            easterEggs = [];
            auroraActive = false;
            auroraAlpha = 0;
            cameraY = 0;
            targetCameraY = 0;
            
            // Get selected city
            currentCity = citySelect.value;
            citySkyline = generateSkyline(currentCity);

            const baseBlock = new Block(
                (canvas.width - INITIAL_WIDTH) / 2,
                canvas.height - 100,
                INITIAL_WIDTH,
                0, 
                0
            );
            blocks.push(baseBlock);

            spawnNextBlock();
        }

        function spawnNextBlock() {
            const prev = blocks[blocks.length - 1];
            const colorIdx = (score + 1); 
            const speed = INITIAL_SPEED + (score * SPEED_INCREMENT);
            const spawnLeft = score % 2 === 0;
            const tempBlock = new Block(0, 0, prev.width, colorIdx, 0);
            const startX = spawnLeft ? -prev.width : canvas.width;
            
            activeBlock = new Block(
                startX,
                prev.y - tempBlock.height, 
                prev.width,
                colorIdx,
                spawnLeft ? speed : -speed
            );

            // Select random gift based on progress
            // Low score = cheaper gifts, High score = expensive gifts
            let maxIndex = Math.min(GIFTS.length - 1, Math.floor(score * 1.5) + 3);
            let minIndex = Math.max(0, Math.floor(score * 0.5));
            // Ensure we have a valid range
            if (minIndex > maxIndex) minIndex = maxIndex;
            
            // Random index within range
            let giftIndex = Math.floor(Math.random() * (maxIndex - minIndex + 1)) + minIndex;
            activeGift = GIFTS[giftIndex] || GIFTS[0];

            // Update UI
            giftNameEl.innerText = activeGift.name;
            giftPriceEl.innerText = formatMoney(activeGift.price);
        }

        // --- Logic ---
        
        function spawnEasterEgg(type) {
            easterEggs.push(new EasterEgg(type, -cameraY));
        }

        function placeBlock() {
            if (state !== 'playing') return;

            // Hide hint on first action
            const hint = document.getElementById('gameHint');
            if (!hint.classList.contains('opacity-0')) {
                hint.classList.add('opacity-0');
            }

            const prev = blocks[blocks.length - 1];
            const curr = activeBlock;
            
            const dist = curr.x - prev.x;
            const overlap = curr.width - Math.abs(dist);

            if (overlap > 0) {
                let newX, newWidth;

                if (dist > 0) {
                    newX = curr.x;
                    newWidth = overlap;
                    const dW = curr.width - newWidth;
                    addDebris(curr.x + newWidth, curr.y, dW, curr.height, curr.colorIndex, 3);
                } else {
                    newX = prev.x;
                    newWidth = overlap;
                    const dW = curr.width - newWidth;
                    addDebris(curr.x, curr.y, dW, curr.height, curr.colorIndex, -3);
                }

                curr.x = newX;
                curr.width = newWidth;
                curr.vx = 0;
                
                blocks.push(curr);
                score++;
                totalValue += activeGift.price;
                
                // EASTER EGGS TRIGGER (Updated Levels)
                if (score === 15) spawnEasterEgg('shooting_star');
                if (score === 30) spawnEasterEgg('plane');
                if (score === 40) auroraActive = true;
                if (score === 50) spawnEasterEgg('rocket');
                
                scoreEl.textContent = score;

                if (score > 2) {
                    targetCameraY += curr.height;
                }

                spawnNextBlock();
            } else {
                gameOver();
            }
        }

        function addDebris(x, y, w, h, cIdx, vx) {
            if (w <= 1) return;
            debris.push(new Debris(x, y, w, h, cIdx, vx));
        }

        function gameOver() {
            state = 'gameover';
            if (activeBlock) {
                addDebris(activeBlock.x, activeBlock.y, activeBlock.width, activeBlock.height, activeBlock.colorIndex, activeBlock.vx);
                activeBlock = null;
            }
            finalScoreEl.innerText = score;
            finalValueEl.innerText = formatMoney(totalValue);
            
            // Track attempts safely
            let attempts = 0;
            try {
                attempts = parseInt(localStorage.getItem('santaStackerAttempts') || '0');
                attempts++;
                localStorage.setItem('santaStackerAttempts', attempts);
            } catch(e) {
                // Ignore storage errors
            }

            // Generate Reward List
            const milestones = [
                { lvl: 15, name: "Shooting Star" },
                { lvl: 30, name: "Banner Plane" },
                { lvl: 40, name: "Northern Lights" },
                { lvl: 50, name: "Mars Rocket" }
            ];

            let html = '<h3 class="font-bold mb-2 text-purple-700 uppercase tracking-wider text-xs">üèÜ Sky Secrets</h3><ul class="text-left text-sm space-y-1 inline-block">';
            
            milestones.forEach(m => {
                const unlocked = score >= m.lvl;
                const icon = unlocked ? '‚úÖ' : 'üîí';
                const style = unlocked ? 'text-green-600 font-bold' : 'text-slate-500';
                html += `<li class="${style}">${icon} Level ${m.lvl}: ${m.name}</li>`;
            });
            html += '</ul>';

            // Secret Hint
            if (attempts > 10) {
                html += '<div class="mt-3 pt-2 border-t border-purple-200 text-xs font-bold text-purple-600 animate-pulse">ü§´ Secret: Tap "Score" 3x to cheat!</div>';
            }

            nextUnlockEl.innerHTML = html;

            // Fail Message Logic
            if (activeGift) {
                failMessageEl.innerHTML = `Failed to deliver: <span class="text-slate-800">${activeGift.name}</span><br>"${activeGift.fail}"`;
            }

            gameOverScreen.classList.add('active');
            giftTicker.classList.remove('active');
        }

        function resetToTitle() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            state = 'start';
            gameOverScreen.classList.remove('active');
            startScreen.style.display = 'block';
            giftTicker.classList.remove('active');
            
            initGame();
            draw();
        }

        function startGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            state = 'playing';
            startScreen.style.display = 'none';
            gameOverScreen.classList.remove('active');
            giftTicker.classList.add('active');
            
            // Show hint at start
            document.getElementById('gameHint').classList.remove('opacity-0');
            
            initGame();
            loop();
        }

        // --- Rendering ---

        function update() {
            if (state === 'playing' && activeBlock) {
                activeBlock.update();
            }
            
            easterEggs.forEach((e, i) => {
                e.update();
                if (!e.active) easterEggs.splice(i, 1);
            });

            debris.forEach((d, i) => {
                d.update();
                if (d.alpha <= 0 || d.y > canvas.height + cameraY + 200) debris.splice(i, 1);
            });

            cameraY += (targetCameraY - cameraY) * 0.1;
            
            snowflakes.forEach(f => {
                f.y += f.speed;
                if(f.y > canvas.height + cameraY) f.y -= canvas.height * 1.5;
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Sky/Stars (Far Background)
            ctx.save();
            ctx.translate(0, cameraY * 0.2); 
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                let dy = (s.y + cameraY * 0.1) % (canvas.height);
                if (dy < 0) dy += canvas.height;
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, dy, s.size, 0, Math.PI*2);
                ctx.fill();
            });
            
            // 1b. Aurora (If active)
            drawAurora(ctx, cameraY);
            
            ctx.restore();

            // 2. City Skyline (Mid Background)
            drawSkyline(ctx, cameraY);
            
            // 2b. Background Easter Eggs (Plane/Rocket/Star)
            ctx.save();
            ctx.translate(0, cameraY * 0.4); // Move slightly slower than blocks
            easterEggs.forEach(e => e.draw(ctx));
            ctx.restore();

            // 3. Snow (Foreground of background)
            ctx.save();
            ctx.translate(0, cameraY * 0.5); 
            ctx.fillStyle = '#fff';
            snowflakes.forEach(f => {
                let dy = (f.y + cameraY * 0.1) % (canvas.height * 1.2);
                if (dy < -200) dy += canvas.height * 1.2;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(f.x, dy, f.size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.restore();

            // 4. World (Game objects)
            ctx.save();
            ctx.translate(0, cameraY);

            // Ground
            ctx.fillStyle = '#334155';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 100);
            ctx.fillStyle = '#cbd5e1'; 
            ctx.fillRect(0, canvas.height - 50, canvas.width, 10);

            blocks.forEach(b => b.draw(ctx));
            debris.forEach(d => d.draw(ctx));

            if (state === 'playing' && activeBlock) {
                activeBlock.draw(ctx);
                sleigh.draw(ctx, activeBlock);
            }

            ctx.restore();
        }

        function loop() {
            update();
            draw();
            if (state !== 'start') {
                animationFrameId = requestAnimationFrame(loop);
            }
        }

        // --- Inputs ---
        function handleInput(e) {
            // Prevent game action if clicking input fields or buttons
            if(e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return; 
            
            e.preventDefault();
            if (state === 'start') startGame();
            else if (state === 'playing') placeBlock();
            else if (state === 'gameover') startGame();
        }

        // --- Cheat Codes & Gestures ---
        
        // 1. Keyboard Cheats (1-4)
        window.addEventListener('keydown', e => { 
            if(e.code === 'Space') {
                handleInput(e);
            }
            // Cheats
            if (e.key === '1') spawnEasterEgg('shooting_star');
            if (e.key === '2') spawnEasterEgg('plane');
            if (e.key === '3') auroraActive = !auroraActive;
            if (e.key === '4') spawnEasterEgg('rocket');
        });
        
        // 2. Touch Gesture: Triple Tap Score
        let tapCount = 0;
        let tapTimer;
        
        scoreEl.addEventListener('mousedown', (e) => {
            e.stopPropagation(); // Don't trigger game action
            tapCount++;
            if (tapTimer) clearTimeout(tapTimer);
            
            tapTimer = setTimeout(() => {
                tapCount = 0;
            }, 500); // Reset if not tapped quickly enough

            if (tapCount === 3) {
                // Trigger a random easter egg
                const cheats = ['shooting_star', 'plane', 'rocket'];
                const random = cheats[Math.floor(Math.random() * cheats.length)];
                
                // 50% chance to toggle aurora, otherwise spawn object
                if (Math.random() > 0.7) {
                    auroraActive = !auroraActive;
                } else {
                    spawnEasterEgg(random);
                }
                
                // Visual feedback
                scoreEl.style.transform = "translateX(-50%) scale(1.5)";
                setTimeout(() => scoreEl.style.transform = "translateX(-50%) scale(1)", 200);
                
                tapCount = 0;
            }
        });
        
        // Fix: Make sure touchstart on score also works for mobile
        scoreEl.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            // Reuse logic is tricky with different event types, simpler to let mousedown handle desktop
            // and just duplicate specific touch logic if needed, but mousedown often fires on touch too.
            // Let's add a specific touch handler just in case to be responsive.
            tapCount++;
            if (tapTimer) clearTimeout(tapTimer);
            tapTimer = setTimeout(() => tapCount = 0, 500);
            if (tapCount === 3) {
                 const cheats = ['shooting_star', 'plane', 'rocket'];
                 spawnEasterEgg(cheats[Math.floor(Math.random() * cheats.length)]);
                 tapCount = 0;
            }
        }, {passive: true});


        window.addEventListener('mousedown', e => { 
            if(e.target.closest('button') || e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT' || e.target.id === 'scoreVal') return;
            handleInput(e); 
        });
        window.addEventListener('touchstart', e => { 
            if(e.target.closest('button') || e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT' || e.target.id === 'scoreVal') return;
            handleInput(e); 
        }, {passive:false});

        restartBtn.addEventListener('click', resetToTitle);
        startBtn.addEventListener('click', startGame);

        // --- Share Feature Logic ---
        
        // 1. Check for greeting on load
        window.onload = function() {
            const urlParams = new URLSearchParams(window.location.search);
            // Default to "Chris" if no name provided
            const fromName = urlParams.get('from') || "Chris";
            
            // Sanitize basic and display
            senderNameEl.textContent = fromName.replace(/[<>]/g, "");
            greetingDisplay.classList.remove('hidden');
            
            // Standard init
            resize();
            initBackground();
            initGame();
            draw();
        };

        // 2. Open Share Modal
        openShareBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            shareModal.classList.add('active');
        });

        // 3. Close Share Modal
        closeShareBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            shareModal.classList.remove('active');
            shareFeedback.style.opacity = '0';
        });

        // 4. Generate Link
        generateLinkBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const name = shareNameInput.value.trim();
            if(!name) return;

            // Construct URL
            const baseUrl = window.location.href.split('?')[0];
            const newUrl = `${baseUrl}?from=${encodeURIComponent(name)}`;
            
            // Copy to clipboard
            navigator.clipboard.writeText(newUrl).then(() => {
                shareFeedback.style.opacity = '1';
                setTimeout(() => {
                    shareFeedback.style.opacity = '0';
                }, 3000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                shareFeedback.textContent = "Could not copy automatically. Check URL bar?";
                shareFeedback.style.opacity = '1';
            });
        });


    </script>
</body>
</html>
